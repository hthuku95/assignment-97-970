content='import json\nimport logging\nfrom channels.generic.websocket import AsyncWebsocketConsumer\nfrom channels.db import database_sync_to_async\nfrom django.contrib.auth import get_user_model\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom .models import Notification\nfrom .serializers import NotificationSerializer\n\nUser = get_user_model()\nlogger = logging.getLogger(__name__)\n\n\nclass NotificationConsumer(AsyncWebsocketConsumer):\n    """\n    WebSocket consumer for handling real-time notifications.\n    Users connect to receive personalized notifications.\n    """\n\n    async def connect(self):\n        """\n        Handle WebSocket connection.\n        Authenticate user and add them to their personal notification group.\n        """\n        self.user = self.scope["user"]\n        \n        # Reject connection if user is not authenticated\n        if not self.user or self.user.is_anonymous:\n            logger.warning("Unauthenticated user attempted to connect to notifications")\n            await self.close()\n            return\n\n        # Create user-specific group name\n        self.group_name = f"notifications_{self.user.id}"\n        \n        try:\n            # Join notification group\n            await self.channel_layer.group_add(\n                self.group_name,\n                self.channel_name\n            )\n            \n            # Accept WebSocket connection\n            await self.accept()\n            \n            # Send unread notifications count on connection\n            unread_count = await self.get_unread_notifications_count()\n            await self.send(text_data=json.dumps({\n                \'type\': \'unread_count\',\n                \'count\': unread_count\n            }))\n            \n            logger.info(f"User {self.user.id} connected to notifications")\n            \n        except Exception as e:\n            logger.error(f"Error connecting user {self.user.id} to notifications: {str(e)}")\n            await self.close()\n\n    async def disconnect(self, close_code):\n        """\n        Handle WebSocket disconnection.\n        Remove user from their notification group.\n        """\n        if hasattr(self, \'group_name\'):\n            try:\n                await self.channel_layer.group_discard(\n                    self.group_name,\n                    self.channel_name\n                )\n                logger.info(f"User {self.user.id} disconnected from notifications")\n            except Exception as e:\n                logger.error(f"Error disconnecting user {self.user.id}: {str(e)}")\n\n    async def receive(self, text_data):\n        """\n        Handle messages received from WebSocket.\n        Process client requests for notifications.\n        """\n        try:\n            data = json.loads(text_data)\n            message_type = data.get(\'type\')\n            \n            if message_type == \'mark_read\':\n                await self.handle_mark_read(data.get(\'notification_id\'))\n            elif message_type == \'mark_all_read\':\n                await self.handle_mark_all_read()\n            elif message_type == \'get_notifications\':\n                await self.handle_get_notifications(data.get(\'page\', 1))\n            else:\n                logger.warning(f"Unknown message type: {message_type}")\n                \n        except json.JSONDecodeError:\n            logger.error("Invalid JSON received from client")\n            await self.send(text_data=json.dumps({\n                \'type\': \'error\',\n                \'message\': \'Invalid JSON format\'\n            }))\n        except Exception as e:\n            logger.error(f"Error processing message: {str(e)}")\n            await self.send(text_data=json.dumps({\n                \'type\': \'error\',\n                \'message\': \'Internal server error\'\n            }))\n\n    async def handle_mark_read(self, notification_id):\n        """\n        Mark a specific notification as read.\n        """\n        if not notification_id:\n            await self.send(text_data=json.dumps({\n                \'type\': \'error\',\n                \'message\': \'Notification ID is required\'\n            }))\n            return\n\n        try:\n            success = await self.mark_notification_read(notification_id)\n            if success:\n                unread_' additional_kwargs={} response_metadata={'id': 'msg_018FzBNSvRXn8gu9biNPtjmA', 'model': 'claude-sonnet-4-20250514', 'stop_reason': 'max_tokens', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 405, 'output_tokens': 1024, 'service_tier': 'standard'}} id='run--26004367-c815-4be7-90c2-7fc4eb7bb4b1-0' usage_metadata={'input_tokens': 405, 'output_tokens': 1024, 'total_tokens': 1429, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}